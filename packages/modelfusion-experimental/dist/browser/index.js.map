{"version":3,"sources":["../../src/browser/MediaSourceAppender.ts","../../src/browser/convertBlobToBase64.ts","../../src/browser/convertAudioChunksToBase64.ts","../../src/browser/invokeFlow.ts","../../src/browser/readEventSource.ts","../../src/browser/readEventSourceStream.ts"],"sourcesContent":["export class MediaSourceAppender {\n  private readonly mediaSource = this.getMediaSource();\n  private readonly audioChunks: ArrayBuffer[] = [];\n\n  private sourceBuffer?: SourceBuffer;\n\n  private getMediaSource() {\n    const anyWindow = (window as any).X;\n\n    if (anyWindow.ManagedMediaSource) {\n      return new anyWindow.ManagedMediaSource();\n    }\n    if (anyWindow.MediaSource) {\n      return new anyWindow.MediaSource();\n    }\n\n    throw \"No MediaSource API available\";\n  }\n\n  constructor(type: string) {\n    this.mediaSource.addEventListener(\"sourceopen\", async () => {\n      this.sourceBuffer = this.mediaSource.addSourceBuffer(type);\n\n      this.sourceBuffer?.addEventListener(\"updateend\", () => {\n        this.tryAppendNextChunk();\n      });\n    });\n  }\n\n  private tryAppendNextChunk() {\n    if (\n      this.sourceBuffer != null &&\n      !this.sourceBuffer.updating &&\n      this.audioChunks.length > 0\n    ) {\n      this.sourceBuffer.appendBuffer(this.audioChunks.shift()!);\n    }\n  }\n\n  public addBase64Data(base64Data: string) {\n    this.addData(\n      Uint8Array.from(atob(base64Data), (char) => char.charCodeAt(0)).buffer\n    );\n  }\n\n  public addData(data: ArrayBuffer) {\n    this.audioChunks.push(data);\n    this.tryAppendNextChunk();\n  }\n\n  public close() {\n    if (this.mediaSource.readyState === \"open\") {\n      this.mediaSource.endOfStream();\n    }\n  }\n\n  public get mediaSourceUrl() {\n    return URL.createObjectURL(this.mediaSource);\n  }\n}\n","export async function convertBlobToBase64(blob: Blob): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n\n    reader.onloadend = () => {\n      if (reader.result) {\n        const base64String = btoa(\n          new Uint8Array(reader.result as ArrayBuffer).reduce(\n            (data, byte) => data + String.fromCharCode(byte),\n            \"\"\n          )\n        );\n        resolve(base64String);\n      } else {\n        reject(new Error(\"Failed to read blob.\"));\n      }\n    };\n\n    reader.onerror = () => {\n      reader.abort();\n      reject(new DOMException(\"Problem parsing input blob.\"));\n    };\n\n    reader.readAsArrayBuffer(blob);\n  });\n}\n","import { convertBlobToBase64 } from \"./convertBlobToBase64.js\";\n\nexport function convertAudioChunksToBase64({\n  audioChunks,\n  mimeType,\n}: {\n  audioChunks: Blob[];\n  mimeType: string;\n}): Promise<string> {\n  return convertBlobToBase64(new Blob(audioChunks, { type: mimeType }));\n}\n","import { zodSchema } from \"modelfusion\";\nimport { FlowSchema } from \"../server/fastify/FlowSchema.js\";\nimport { readEventSource } from \"./readEventSource.js\";\n\nexport async function invokeFlow<INPUT, EVENT>({\n  url,\n  input,\n  schema,\n  onEvent,\n  onStop,\n}: {\n  url: string;\n  input: INPUT;\n  schema: FlowSchema<INPUT, EVENT>;\n  onEvent: (event: EVENT, eventSource: EventSource) => void;\n  onStop?: (eventSource: EventSource) => void;\n}) {\n  const response = await fetch(url, {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify(input),\n  });\n\n  const eventSourceUrl: string = (await response.json()).url;\n\n  readEventSource({\n    url: eventSourceUrl,\n    schema: zodSchema(schema.events),\n    isStopEvent(event) {\n      return event.data === \"[DONE]\";\n    },\n    onEvent,\n    onStop,\n  });\n}\n","import { Schema, safeParseJSON } from \"modelfusion\";\n\nexport function readEventSource<T>({\n  url,\n  schema,\n  onEvent,\n  onError = console.error,\n  onStop,\n  isStopEvent,\n}: {\n  url: string;\n  schema: Schema<T>;\n  onEvent: (event: T, eventSource: EventSource) => void;\n  onError?: (error: unknown, eventSource: EventSource) => void;\n  onStop?: (eventSource: EventSource) => void;\n  isStopEvent?: (event: MessageEvent<unknown>) => boolean;\n}) {\n  const eventSource = new EventSource(url);\n\n  eventSource.onmessage = (event) => {\n    try {\n      if (isStopEvent?.(event)) {\n        eventSource.close();\n        onStop?.(eventSource);\n        return;\n      }\n\n      const parseResult = safeParseJSON({ text: event.data, schema });\n\n      if (!parseResult.success) {\n        onError(parseResult.error, eventSource);\n        return;\n      }\n\n      onEvent(parseResult.value, eventSource);\n    } catch (error) {\n      onError(error, eventSource);\n    }\n  };\n\n  eventSource.onerror = (e) => {\n    onError(e, eventSource);\n  };\n}\n","import { AsyncQueue, Schema, safeParseJSON } from \"modelfusion\";\nimport { ErrorHandler, parseEventSourceStream } from \"modelfusion/internal\";\n\nexport function readEventSourceStream<T>({\n  stream,\n  schema,\n  errorHandler,\n}: {\n  stream: ReadableStream<Uint8Array>;\n  schema: Schema<T>;\n  errorHandler?: ErrorHandler;\n}): AsyncIterable<T> {\n  const queue = new AsyncQueue<T>();\n\n  // run async (no await on purpose):\n  parseEventSourceStream({ stream })\n    .then(async (events) => {\n      try {\n        for await (const event of events) {\n          const validationResult = safeParseJSON({ text: event.data, schema });\n\n          if (!validationResult.success) {\n            errorHandler?.(validationResult.error);\n            continue;\n          }\n\n          queue.push(validationResult.value);\n        }\n      } catch (error) {\n        errorHandler?.(error);\n      } finally {\n        queue.close();\n      }\n    })\n    .catch((error) => {\n      errorHandler?.(error);\n      queue.close();\n    });\n\n  return queue;\n}\n"],"mappings":"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","names":["safeParseJSON"]}